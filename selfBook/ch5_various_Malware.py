# 하나의 악성코드가 아닌, 다양한 악성코드를 진단/치료하기
# - if elif else 를 사용하여 악성코드 한개가 아닌, 두개를 진단할 수 있다.
# - 리스트 자료구조를 통해 키와 벨류 형태로 악성코드 데이터베이스를 생성할 수 있다.
exVirusDB = [ '44d88612fea8 : ERICA TEST',
              '77bff0b14402 : Ransomware',
              '888999222rjr : Trojan']
# 이후, for() 문과 range()문을 사용하여 각각의 악성코드에 접근 및 비교한다.

import sys
import os
import hashlib

vdb = []

# 악성코드 가공 및 db 저장
def MakeVirusDB() :
    for pattern in exVirusDB :
        t = []
        v = pattern.split(':')
        t.append(v[0]) # t0 에는 악성코드 디비에서 분리된 해쉬값을 저장한다.
        t.append(v[1]) # t1 에는 악성코드 디비에서 분리된 이름을 저장한다.
        vdb.append(t)

# 악성코드 검사
def SearchVDB (fmd5) :
    for t in vdb :
        if t [0] == fmd5 :
            return True, t[1] # 해쉬가 동일하면 악성코드 이름을 함께 리턴

    return False, '' # 악성코드가 발견되지 않으면 끝

if __name__ == '__main__':
    MakeVirusDB() # 데이터베이스 가공

    if len(sys.argv) != 2 :
        print('Usage : antivirus.py [file]')
        exit(0)
    # 위코드는 아래와 같은 형식에 맞지 않다면, 형식을 지키라는 이야기임
    # python antivirus.py testfile.exe  # .py 로 .exe를 검사하겠다
    # java -jar == python, (해당스크립트 주체) -> (검사를 당할 파일인 객체)

    fname = sys.argv[1]  # 검사할 파일의 이름을 가져옴

    fp = open(fname, 'rb')
    # 파일을 바이너리 모드(rb)로 열기
    # 해시 계산을 위해 파일 내용을 그대로 읽어야 함,
    # 텍스트 모드(r)로 읽으면 줄바꿈(\n -> \r\n) 등이 변형될 수 있음.
    buf = fp.read()  # 파일의 모든 데이터를 읽어 buf 변수에 저장
    fp.close()  # 파일 닫기
#백신 검사 속도를 높이려면, 위와 같은 방법은 지양해야 한다.
    # * file open 은 최대한 자제
    # * read() 는 파일 전체 내용을 읽기 때문에 무조건 리드해서는 안된다.
    # * 악성코드 DB와의 비교 횟수는 최대한 줄인다.
    # => 악성코드 디비에 파일 크기를 추가하여, 파일크기 변동이 없다면 비교를 하지 않는다.
    # 44d88 : Malware -> 65 : 44d8 : Malware


    m = hashlib.md5()  # MD5 해시 객체 생성
    m.update(buf)  # 파일의 내용을 해시 객체에 전달
    fmd5 = m.hexdigest()  # 최종 MD5 해시 값을 16진수 문자열로 반환

    ret, vname = SearchVDB(fmd5)
    if ret == True :
        print('%s : %s' % (fmd5, vname))
        os.remove(fname)
    else :
        print('%s : ok' % (fname))


# [v2]
# import sys
# import os
# import hashlib
#
# vdb = []
#
# def MakeVirusDB():
#     for pattern in exVirusDB:
#         v = pattern.split(':')
#         vdb.append([v[0].strip(), v[1].strip()])  # 불필요한 리스트 사용 없이 간결하게 저장
#
# def SearchVDB(fmd5):
#     for t in vdb:
#         if t[0] == fmd5:
#             return True, t[1]
#     return False, ''
#
# if __name__ == '__main__':
#     MakeVirusDB()
#
#     if len(sys.argv) != 2:
#         print('Usage: antivirus.py [file]')
#         exit(0)
#
#     fname = sys.argv[1]
#
#     if not os.path.exists(fname):  # 파일 존재 여부 확인
#         print("Error: File not found!")
#         exit(1)
#
#     with open(fname, 'rb') as fp:
#         buf = fp.read()
#
#     m = hashlib.sha256()  # SHA-256으로 변경
#     m.update(buf)
#     fhash = m.hexdigest()
#
#     ret, vname = SearchVDB(fhash)
#     if ret:
#         print(f"{fhash} : {vname}")
#         os.remove(fname)
#     else:
#         print(f"{fname} : ok")

v3.version

import sys
import os
import hashlib

vdb = {}

# 악성코드 데이터베이스
exVirusDB = [
    '65:44d88612fea8:ERICA TEST',
    '120:77bff0b14402:Ransomware',
    '200:888999222rjr:Trojan'
]

# 악성코드 DB 가공 (파일 크기 추가)
def MakeVirusDB():
    for pattern in exVirusDB:
        size, hash_value, name = pattern.split(':')
        vdb[int(size)] = {hash_value: name}

# 악성코드 검사
def SearchVDB(file_size, fhash):
    if file_size in vdb:  # 파일 크기가 일치하는 경우만 검사
        if fhash in vdb[file_size]:
            return True, vdb[file_size][fhash]
    return False, ''

if __name__ == '__main__':
    MakeVirusDB()  # 데이터베이스 가공

    if len(sys.argv) != 2:
        print('Usage: antivirus.py [file]')
        exit(0)

    fname = sys.argv[1]

    if not os.path.exists(fname):
        print("Error: File not found!")
        exit(1)

    file_size = os.path.getsize(fname)  # 파일 크기 확인

    if file_size not in vdb:
        print(f"{fname} : ok (size mismatch)")
        exit(0)

    with open(fname, 'rb') as fp:
        buf = fp.read(4096)  # 앞부분 4KB만 해싱

    m = hashlib.sha256()  # SHA-256 해시 사용
    m.update(buf)
    fhash = m.hexdigest()

    ret, vname = SearchVDB(file_size, fhash)
    if ret:
        print(f"{fname} : {vname} (Malware Detected)")
        os.remove(fname)
    else:
        print(f"{fname} : ok")